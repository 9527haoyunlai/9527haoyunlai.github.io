<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>特殊文件，日志技术，多线程 | 9527好运来的博客</title><meta name="author" content="好运来"><meta name="copyright" content="好运来"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="day11-特殊文件、日志技术、多线程一、属性文件1.1 特殊文件概述前面学习了IO流，知道IO流是用来读、写文件中的数据。但是我们接触到的文件都是普通的文本文件，普通的文本文件里面的数据是没有任何格式规范的，用户可以随意编写，如下图所示。 像这种普通的文本文件，没有任何规律可言，不方便程序对文件中的数据信息处理。  在以后的Java开发过程中还会遇到一些特殊的文本文件，这些文件是有一些格式要求的">
<meta property="og:type" content="article">
<meta property="og:title" content="特殊文件，日志技术，多线程">
<meta property="og:url" content="https://9527haoyunlai.github.io/2024/07/09/JavaSE/day10-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="9527好运来的博客">
<meta property="og:description" content="day11-特殊文件、日志技术、多线程一、属性文件1.1 特殊文件概述前面学习了IO流，知道IO流是用来读、写文件中的数据。但是我们接触到的文件都是普通的文本文件，普通的文本文件里面的数据是没有任何格式规范的，用户可以随意编写，如下图所示。 像这种普通的文本文件，没有任何规律可言，不方便程序对文件中的数据信息处理。  在以后的Java开发过程中还会遇到一些特殊的文本文件，这些文件是有一些格式要求的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://9527haoyunlai.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-07-09T06:07:25.000Z">
<meta property="article:modified_time" content="2024-07-09T09:51:23.571Z">
<meta property="article:author" content="好运来">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://9527haoyunlai.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://9527haoyunlai.github.io/2024/07/09/JavaSE/day10-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '特殊文件，日志技术，多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-09 17:51:23'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="9527好运来的博客"><span class="site-name">9527好运来的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">特殊文件，日志技术，多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-07-09T06:07:25.000Z" title="Created 2024-07-09 14:07:25">2024-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-07-09T09:51:23.571Z" title="Updated 2024-07-09 17:51:23">2024-07-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="特殊文件，日志技术，多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="day11-特殊文件、日志技术、多线程"><a href="#day11-特殊文件、日志技术、多线程" class="headerlink" title="day11-特殊文件、日志技术、多线程"></a>day11-特殊文件、日志技术、多线程</h1><h2 id="一、属性文件"><a href="#一、属性文件" class="headerlink" title="一、属性文件"></a>一、属性文件</h2><h3 id="1-1-特殊文件概述"><a href="#1-1-特殊文件概述" class="headerlink" title="1.1 特殊文件概述"></a>1.1 特殊文件概述</h3><p>前面学习了IO流，知道IO流是用来读、写文件中的数据。但是我们接触到的文件都是普通的文本文件，普通的文本文件里面的数据是没有任何格式规范的，用户可以随意编写，如下图所示。</p>
<p>像这种普通的文本文件，没有任何规律可言，不方便程序对文件中的数据信息处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667990938340.png" alt="1667990938340"></p>
<p>在以后的Java开发过程中还会遇到一些特殊的文本文件，这些文件是有一些格式要求的，方便程序对文件中的数据进行处理。</p>
<p>比如，后面我们会用到两种特殊的文本文件，一种是properties文件，还有一种是xml文件。如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667991153379.png" alt="1667991153379"></p>
<ul>
<li>后缀为.properties的文件，称之为属性文件，它可以很方便的存储一些类似于键值对的数据。经常当做软件的配置文件使用。</li>
<li>而xml文件能够表示更加复杂的数据关系，比如要表示多个用户的用户名、密码、家乡、性别等。在后面，也经常当做软件的配置文件使用。</li>
</ul>
<p>为什么要使用这些特殊文件？</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240306164547342.png" alt="image-20240306164547342"></p>
<p>普通文件存储信息没有格式，不能存内容之间的关系。不好读出来，不好区分。如果使用属性文件来读的话，里面存放的是键值对信息，这些东西读出后是可以解析的。xml也存进去了数据关系也可以</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240306164925629.png" alt="image-20240306164925629"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240306165555905.png" alt="image-20240306165555905"></p>
<p>这就是我们为什么要用这些特殊文件，它可以将这些特殊关系存进去。方便我们读出数据后解析用户名和密码。</p>
<p>属性文件：适合存放一个用户。XML文件：适合存放多多个用户。</p>
<p>存储有关系的数据，可以作为系统的配置文件。也可以做为信息进行传输。</p>
<p>现在，学习特殊的文件主要学习什么呢？ 主要学习以下的三点</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667991441046.png" alt="1667991441046"></p>
<h2 id="二、Properties属性文件"><a href="#二、Properties属性文件" class="headerlink" title="二、Properties属性文件"></a>二、Properties属性文件</h2><h3 id="2-1-属性文件的格式："><a href="#2-1-属性文件的格式：" class="headerlink" title="2.1 属性文件的格式："></a>2.1 属性文件的格式：</h3><ol>
<li>属性文件后缀以<code>.properties</code>结尾</li>
<li>属性文件里面的每一行都是一个键值对，键和值中间用&#x3D;隔开。比如: <code>admin=123456</code> </li>
<li><code>#</code>表示这样是注释信息，是用来解释这一行配置是什么意思。</li>
<li>每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。</li>
<li>键不能重复，值可以重复</li>
</ol>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667992083258.png" alt="1667992083258"></p>
<h3 id="2-2-读取属性文件中的数据"><a href="#2-2-读取属性文件中的数据" class="headerlink" title="2.2 读取属性文件中的数据"></a>2.2 读取属性文件中的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Properties是什么？</span><br><span class="line">	Properties是Map接口下面的一个实现类，所以Properties也是一种双列集合，用来存储键值对。	  但是一般不会把它当做集合来使用。</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>Properties核心作用？</span><br><span class="line">	Properties类的对象，用来表示属性文件，可以用来读取属性文件中的键值对。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240306172110731.png" alt="image-20240306172110731"></p>
<ul>
<li><strong>使用Properties读取属性文件中的键值对</strong>，需要用到的方法如下。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667992486134.png" alt="1667992486134"></p>
<p>实用Properties读取属性文件的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、创建一个Properties的对象出来（键值对集合，空容器）</span><br><span class="line"><span class="number">2</span>、调用load(字符输入流/字节输入流)方法，开始加载属性文件中的键值对数据到properties对象中去</span><br><span class="line"><span class="number">3</span>、调用getProperty(键)方法，根据键取值</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用Properties类读取属性文件中的键值对信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Properties的对象出来（键值对集合，空容器）</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始加载属性文件中的键值对数据到properties对象中去</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;properties-xml-log-app\\src\\users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、根据键取值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;赵敏&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;张无忌&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、遍历全部的键和值。</span></span><br><span class="line">        <span class="comment">// 拿到全部键的集合</span></span><br><span class="line">        Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 遍历键，根据键取值。</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// properties是Map集合，Map集合还有一种遍历方式就是通过JDK1.8提供的forEach的lambda表达式来遍历</span></span><br><span class="line">        properties.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然我们可以使用Properties读取属性文件里面的键值对数据，在开发中我们可能也需要把键值对文件存储到属性文件中去。</p>
<h3 id="2-3-往属性文件中写键值对"><a href="#2-3-往属性文件中写键值对" class="headerlink" title="2.3 往属性文件中写键值对"></a>2.3 往属性文件中写键值对</h3><ul>
<li><strong>使用Properties往属性文件中写键值对</strong>需要用到的方法如下</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667993320872.png" alt="1667993320872"></p>
<p>往Properties属性文件中写键值对的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、先准备一个.properties属性文件，按照格式写几个键值对</span><br><span class="line"><span class="number">1</span>、创建Properties对象出来，</span><br><span class="line"><span class="number">2</span>、调用setProperty存储一些键值对数据</span><br><span class="line"><span class="number">3</span>、调用store(字符输出流/字节输出流, 注释)，将Properties集合中的键和值写到文件中</span><br><span class="line">	注意：第二个参数是注释，必须得加；</span><br></pre></td></tr></table></figure>

<p>先准备一个<code>users.properties</code>属性文件，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667993682237.png" alt="1667993682237"></p>
<p>接下来，编写代码读取上面的属性文件。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Properties对象出来，先用它存储一些键值对数据</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 把要存到属性文件中的键值对数据调用setProperty方法，先存到properties对象里去。</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;minmin&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;殷素素&quot;</span>, <span class="string">&quot;cuishan&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;susu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把properties对象中的键值对数据存入到属性文件中去，可以以字符输出流和字节输出流的方式保存，第二参数是注释信息。</span></span><br><span class="line">        <span class="comment">// 这个字符输出流的管道不需要自己去关闭，它作为一个参数给到stor方法，内部用完管道后会自动帮助关闭。</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/users2.properties&quot;</span>)</span><br><span class="line">                         , <span class="string">&quot;i saved many users!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，<code>user2.properties</code> 配置文件打开效果如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667993581146.png" alt="1667993581146"></p>
<p><strong>问题：</strong></p>
<p>Properties的作用？具体如何使用？</p>
<p>Properties是Map下的一个实现类，可以往属性文件里读写键值对数据。</p>
<p>Properties读取文件先用Properties构造器构造一个空的Properties集合对象，再用load方法将键值对数据加载到Properties对象中去，参数为文件字符输入流或者文件字节输入流。再通过getProperty方法根据键取值。也可以用Map集合的foEach方法的lambda表达式实现遍历。</p>
<p>Properties往属性文件里写入键值对，首先构造一个Properties对象，调用setProperty(键，值)的方法(键值对只要字符串)先存到properties对象里去。最后通过store方法把properties对象里的数据存放到属性文件中，第一个参数为文件字符输出流或者文件字符输入流对象，第二个参数为注释信息。字符输出流作为参数会自动关闭。</p>
<p><strong>案例：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240306180750545.png" alt="image-20240306180750545"></p>
<p>判断这个文件中是否有李方，有的话将名字改为18岁。</p>
<p>这个文件虽然是txt结尾的，但是本质上也是属性文件，因为它里面全是键值对。属性文件只看内容的，如果内容全是键值对占一行那么它就是属性文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目标：查找李方的名字，改为18。满足属性文件的要求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1、创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 2、将键值对拿到properties对象中</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;properties-xml-log-app\\src\\mingzi.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 3、查找properties对象中的内容看是否包括李方</span></span><br><span class="line">        <span class="keyword">if</span>(properties.containsKey(<span class="string">&quot;李方&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 4.修改键值对</span></span><br><span class="line">            properties.setProperty(<span class="string">&quot;李方&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5、将修改后的结果写回属性文件</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app\\src\\mingzi.txt&quot;</span>),<span class="string">&quot;success!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、XML文件"><a href="#三、XML文件" class="headerlink" title="三、XML文件"></a>三、XML文件</h2><p>接下来学习一种在开发中经常使用的文件，叫做xml文件。我们先来介绍一下，什么是xml文件，然后再来学习如何读取xml文件中的数据。</p>
<h3 id="2-1-XML文件概述"><a href="#2-1-XML文件概述" class="headerlink" title="2.1 XML文件概述"></a>2.1 XML文件概述</h3><p><strong>首先，我们来认识一下，什么是XML？</strong></p>
<p>XML是可扩展的标记语言(Extensible Markup Language)，意思是它是由一些标签组成的，而这些标签是自己定义的。<strong>本质上一种数据格式，可以用来表示复杂的数据关系。</strong></p>
<p>XML文件有如下的特点：</p>
<ul>
<li>XML中的<code>&lt;标签名&gt;</code> 称为一个标签或者一个元素，一般是成对出现的。</li>
<li>XML中的标签名可以自己定义（可扩展），但是必须要正确的嵌套</li>
<li>XML中只能有一个根标签，子标签可以有多个。</li>
<li>XML标准中可以有属性，属性是由键和值组成的。</li>
<li>XML<strong>必须第一行有一个文档声明</strong>，格式是固定的<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></li>
<li>XML文件必须是以.xml为后缀结尾</li>
</ul>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667993965682.png" alt="1667993965682"></p>
<p><strong>接下，同学们可以跟着步骤新建一个XML文件，试试！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667994441934.png" alt="1667994441934"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  根标签只能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一个用户&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张无忌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>minmin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span>&gt;</span>很多人<span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>敏敏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>wuji<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面XML文件中的数据格式是最为常见的，标签有属性、文本、还有合理的嵌套。<strong>XML文件中除了写以上的数据格式之外，还有一些特殊的字符不能直接写。</strong></p>
<ul>
<li><p>像 <code>&lt;,&gt;,&amp; </code>等这些符号不能出现在标签的文本中，因为标签格式本身就有&lt;&gt;，会和标签格式冲突。</p>
<p>如果标签文本中有这些特殊字符，需要用一些占位符代替。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;  表示 &lt;</span><br><span class="line">&amp;gt;  表示 &gt;</span><br><span class="line">&amp;amp; 表示 &amp;</span><br><span class="line">&amp;apos; 表示 &#x27;</span><br><span class="line">&amp;quot; 表示 &quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span> 3 <span class="symbol">&amp;lt;</span> 2 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> 5 <span class="symbol">&amp;gt;</span> 4 <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在标签文本中，出现大量的特殊字符，不想使用占位符，此时可以用CDATA区(特殊数据区，里面可以写任意内容)，格式如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data1</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">   		3 &lt; 2 &amp;&amp; 5 &gt; 4</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">data1</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>XML可以在浏览器中渲染出来的。</p>
<p><strong>最后，XML在实际开发中有什么作用？</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667995490654.png" alt="1667995490654"></p>
<p>由于XML是一种特殊的数据结构，可以表示复杂的数据关系，所以一般用XML来做配置文件以及作为数据在网络中传输。</p>
<p><strong>问题：</strong></p>
<p>XML是什么？XML的组成有啥特点？</p>
<p>XML是可扩展标记语言(EXtensible Makeup Language)，本质上是一种特殊的数据结构，可以表示复杂的数据关系。</p>
<p>XML的标签名可以自己定义，是成对出现的。XML只能有一个根标签，子标签可以有多个。XML标准中可以有属性，属性一般由键和值构成。XML第一行必须有声明，文件要以.xml结尾。XML有一些特殊字符不能写，如果标签中有特殊字符需要用占位符代替，也可以在CDATA区(特殊数据区)书写。</p>
<p>XML的作用是什么？</p>
<p>作为系统的配置文件或者以一种特殊的数据格式在网络中传输。</p>
<h3 id="2-2-XML解析1"><a href="#2-2-XML解析1" class="headerlink" title="2.2 XML解析1"></a>2.2 XML解析1</h3><p>使用程序读取XML文件中的数据，称之为XML解析。</p>
<p>XML中的数据格式很丰富，程序员不需要自己写IO流代码来解析XML，难度较大！也相当繁琐！</p>
<p>其实有很多开源的，好用的XML解析框架，最知名的是DOM4J（第三方开发的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667996374837.png" alt="1667996374837"></p>
<p>由于DOM4J是第三方提供的，所以需要把第三方提供的Jar包导入到自己的项目中来，才可以使用。具体步骤如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667996538290.png" alt="1667996538290"></p>
<p>DOM4J解析XML文件的思想是：文档对象模型（意思是把整个XML文档、每一个标签、每一个属性都等都当做对象来看待）。</p>
<p>Dom4j通过SAXReader解析器对象把XML文件一下子加载到内存中去，它会把这个XML文件变成一个Document文档对象。这个文档对象就会代表整个XML文件，接着就可以通过整个文档对象来解析XML文档中的数据。通过整个文档对象去获取它下面的Element元素(标签)对象，通过元素对象可以拿到属性对象，再通过属性对象拿到键和值。还可以拿到文件对象的文本数据。</p>
<p>一句话：<strong>Dom4j会通过SAXReader解析器把XML文件直接加载成一个文档对象，再从文档对象中去拿元素对象、属性对象、子元素和文本内容，最终把XML文件中的数据全部解析出来了。</strong></p>
<p>Dowument对象表示真个XML文档、Element对象表示标签（元素）、Attribute对象表示属性、标签中的内容就是文本</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667996650787.png" alt="1667996650787"></p>
<p>DOM4J解析XML需要用到的方法如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667996750188.png" alt="1667996750188"></p>
<p>XML解析的过程，是从根元素开始，从外层往里层解析。 我们先把Document对象，和根元素获取出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象，代表Dom4J</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。这个文档就代表整个XML文件</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了，拿到根元素对象，指代的就是users这个根元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());  <span class="comment">// 输出users </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667996995326.png" alt="1667996995326"> </p>
<h3 id="2-3-XML解析2"><a href="#2-3-XML解析2" class="headerlink" title="2.3 XML解析2"></a>2.3 XML解析2</h3><p>获取到XML文件的根元素之后，接下来，就可以用根元素在获取到它里面的子元素（包括子标签、表属性等）。</p>
<p>Dom4J解析是一种自上而下式的解析思想，必须先拿到文档对象，再通过文档对象拿到根元素对象，才可以去用根元素对象去拿到下面的子元素对象。再通过子元素对象拿到它下面这些子元素对象(姓名、性别这些)。所以只能自上而下一级一级的解析。如何从根元素对象拿到子元素对象。需要用到的方法如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1667997211327.png" alt="1667997211327"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240307002252636.png" alt="image-20240307002252636"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、获取根元素下的全部一级子元素。</span></span><br><span class="line">        <span class="comment">// List&lt;Element&gt; elements = root.elements(); // 获取根元素下的一级子元素，它会把这些子元素放到一个List集合里。         // 通过element.getName()输出结果为所有子元素user、people、user</span></span><br><span class="line">        List&lt;Element&gt; elements = root.elements(<span class="string">&quot;user&quot;</span>); <span class="comment">// 指定拿user这样的子元素</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            System.out.println(element.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取当前元素下的某个子元素。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">people</span> <span class="operator">=</span> root.element(<span class="string">&quot;people&quot;</span>); <span class="comment">// 单数</span></span><br><span class="line">        System.out.println(people.getText());<span class="comment">// 获取子元素的内容:很多人</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下面有很多子元素user，默认获取第一个。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">user</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 拿它下面一级子元素name的文本内容：张无忌</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取元素的属性信息呢？</span></span><br><span class="line">        System.out.println(user.attributeValue(<span class="string">&quot;id&quot;</span>)); <span class="comment">// 获取id的属性值为1</span></span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">id</span> <span class="operator">=</span> user.attribute(<span class="string">&quot;id&quot;</span>); <span class="comment">// 通过user这个子元素调用attribute指定名字为id,这样可以拿到id属性对象</span></span><br><span class="line">        System.out.println(id.getName()); <span class="comment">//通过id属性对象调用getName取到属性名</span></span><br><span class="line">        System.out.println(id.getValue()); <span class="comment">//调用getValue拿到属性值</span></span><br><span class="line"></span><br><span class="line">        List&lt;Attribute&gt; attributes = user.attributes(); <span class="comment">// 拿到所有的属性</span></span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123; <span class="comment">// 遍历拿到user下全部属性名和属性值。输出id=1,des=第一个用户。</span></span><br><span class="line">            System.out.println(attribute.getName() + <span class="string">&quot;=&quot;</span> + attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、如何获取全部的文本内容:获取当前元素下的子元素文本值</span></span><br><span class="line">        <span class="comment">// 用user当前子元素调用elementText拿它下面子元素文本值</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;地址&quot;</span>));</span><br><span class="line">        System.out.println(user.elementTextTrim(<span class="string">&quot;地址&quot;</span>)); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种，先通过user子元素再拿到下面子元素对象data，再通过子元素get它的Text获取文本也可以。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">data</span> <span class="operator">=</span> user.element(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        System.out.println(data.getText());</span><br><span class="line">        System.out.println(data.getTextTrim()); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>dom4J解析XML的思想是什么？具体怎么实现的？</p>
<p>Dom4J解析是一种自上而下式的解析思想，必须先拿到文档对象，再通过文档对象拿到根元素对象，才可以去用根元素对象去拿到下面的子元素对象。再通过子元素对象拿到它下面这些子元素对象(姓名、性别这些)。</p>
<p>Dom4J通过SAXReader解析器对象把XML文件一下子加载到内存中去，它会把这个XML文件变成一个Document文档对象。这个文档对象就会代表整个XML文件，接着就可以通过这个文档对象来解析XML文档中的数据。通过整个文档对象去获取它下面的Element元素对象也称为标签对象，通过标签对象可以拿到属性对象，再通过属性对象拿到属性值。还可以拿到文件对象的文本数据。</p>
<h3 id="2-4-XML文件写入"><a href="#2-4-XML文件写入" class="headerlink" title="2.4 XML文件写入"></a>2.4 XML文件写入</h3><p>在前面我们已经学习了XML解析，意思就是使用程序把XML文件中的数据读取出来。反过来能不能往XML文件中写入数据呢？ 答案是可以的。</p>
<p>DOM4J也提供了往XML文件中写标签的方法，但是用起来比较麻烦。这里不建议使用</p>
<p>我们自己使用StringBuilder按照标签的格式拼接，然后再使用BufferedWriter写到XML文件中去就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、使用一个StringBuilder对象来拼接XML格式的数据。</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;book&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;name&gt;&quot;</span>).append(<span class="string">&quot;从入门到跑路&quot;</span>).append(<span class="string">&quot;&lt;/name&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;author&gt;&quot;</span>).append(<span class="string">&quot;dlei&quot;</span>).append(<span class="string">&quot;&lt;/author&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;\t&lt;price&gt;&quot;</span>).append(<span class="number">999.99</span>).append(<span class="string">&quot;&lt;/price&gt;\r\n&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;/book&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/book.xml&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-XML约束（了解）"><a href="#2-5-XML约束（了解）" class="headerlink" title="2.5 XML约束（了解）"></a>2.5 XML约束（了解）</h3><p>各位小伙伴，关于XML还有最后一个知识需要大家了解一下。这个知识叫做约束XML文件的编写，我讲这个知识的目的是因为同学们以后在开发过程中会遇到这个知识，但是这个代码不需要大家写，了解一下就可以了。</p>
<p><strong>首先，说一些什么是XML约束？</strong></p>
<p>XML约束指的是限制XML文件中的标签或者属性，只能按照规定的格式写。</p>
<p>比如我在项目中，想约束一个XML文件中的标签只能写&lt;书&gt;、&lt;书名&gt;、&lt;作者&gt;、&lt;售价&gt;这几个标签，如果写其他标签就报错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668001422123.png" alt="1668001422123"></p>
<p>怎么才能达到上面的效果呢？有两种约束技术，一种是DTD约束、一种是Schame约束。</p>
<ul>
<li><p>DTD约束案例</p>
<p>如下图所示book.xml中引入了DTD约束文件，book.xml文件中的标签就受到DTD文件的约束</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668001621567.png" alt="1668001621567"></p>
<p>DTD文件解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 书架(书+)&gt;   表示根标签是&lt;书架&gt;，并且书架中有子标签&lt;书&gt;</span><br><span class="line">&lt;!ELEMENT 书(书名、作者、售价)&gt; 表示书是一个标签，且书中有子标签&lt;书名&gt;、&lt;作者&gt;、&lt;售价&gt;</span><br><span class="line">&lt;!ELEMENT 书名(#PCDATA)&gt;	表示&lt;书名&gt;是一个标签，且&lt;书名&gt;里面是普通文本</span><br><span class="line">&lt;!ELEMENT 作者(#PCDATA)&gt;	表示&lt;作者&gt;是一个标签，且&lt;作者&gt;里面是普通文本</span><br><span class="line">&lt;!ELEMENT 售价(#PCDATA)&gt;	表示&lt;售价&gt;是一个标签，且&lt;售价&gt;里面是普通文本</span><br></pre></td></tr></table></figure>


</li>
<li><p>Schame约束案例</p>
<p>如下图所示，左边的book2.xml文件就受到右边schame文件（.xsd结尾的文件）的约束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668001745089.png" alt="1668001745089"></p>
</li>
</ul>
<h2 id="四、日志技术"><a href="#四、日志技术" class="headerlink" title="四、日志技术"></a>四、日志技术</h2><h3 id="3-1-日志概述"><a href="#3-1-日志概述" class="headerlink" title="3.1 日志概述"></a>3.1 日志概述</h3><p>想搞清楚什么是日志，其实可以通过下面几个问题来了解的。</p>
<ul>
<li>系统系统能记住某些数据被谁操作，比如被谁删除了？</li>
<li>想分析用户浏览系统的具体情况，比如挖掘用户的具体喜好？</li>
<li>当系统在开发中或者上线后出现了Bug，崩溃了，该通过什么去分析，定位Bug?</li>
</ul>
<p>而日志就可以帮我们解决以上的问题。所以日志就好比生活中的日记，日记可以记录生活中的点点滴滴；而程序中的日志，通常就是一个文件，里面记录了程序运行过程中产生的各种数据。</p>
<p>之前记录日志是通过输出语句把日志输出到控制台上面。</p>
<p>输出语句的弊端，一旦关掉控制台日志信息就消失了，项目上线之后就没有控制台了。所以使用输出语句直接输出到控制台是不靠谱的。</p>
<p>在实际开发中，我们应该把日志放到文件中去，方便程序员实时定位。</p>
<p>日志文件：<strong>把程序运行的信息，记录到文件中，方便程序员定位bug、并了解程序的执行情况。</strong></p>
<p>日志技术有如下好处</p>
<ol>
<li>日志可以将系统执行的信息，方便的记录到指定位置，可以是控制台、可以是文件、可以是数据库中。</li>
<li>日志可以随时以开关的形式控制启停，无需侵入到源代码中去修改。</li>
</ol>
<p><strong>掌握：</strong></p>
<p>什么是日志？</p>
<p>日志就是将系统执行的信息记录到指定的位置，可以是控制台、文件或者是数据库。日志通常是一个文件，方便程序员定位bug，了解程序执行情况。</p>
<p>输出语句存在的问题？日志技术应该具备哪些特点和优势？</p>
<p>输出语句一旦控制台关掉日志信息就消失，项目上线后没有控制台，而且更改日志信息还得去源代码中修改。</p>
<p>日志技术应具备随时以开关的形式控制启停，无需侵入到源代码中去修改。</p>
<h3 id="3-2-日志的体系"><a href="#3-2-日志的体系" class="headerlink" title="3.2 日志的体系"></a>3.2 日志的体系</h3><p>接下来需要学习有哪些日志技术，以及日志的体系。</p>
<p>在行内，其实有很多日志框架给开发者使用。所谓日志框架就是由一些牛人或者第三方公司已经做好的实现代码，后来者就可以直接拿过去使用，就可以在程序中记录日志了。</p>
<p>日志框架有很多种，比如有Java提供的JUL（java.util.logging）框架第三方提供的Log4j、logback等。但是这些日志框架如果使用的API方法都不一样的话，使用者的学习成本就很高。为了降低程序员的学习压力，行内提供了一套<strong>日志接口</strong>，它是设计日志框架的一套标准，所有的日志框架都需要实现这些API接口。</p>
<p>这样程序员只要会一套日志框架，那么其他的也就可以通用，甚至可以在多套日志框架之间来回切换。比较常用的日志框架，和日志接口的关系如下图所示</p>
<p><strong>框架是去实现日志接口  Logback实现了SLF4J的接口规范</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668044513873.png" alt="1668044513873"></p>
<p><strong>这里推荐同学们使用Logback日志框架，也在行业中最为广泛使用的。</strong></p>
<p><strong>Logback日志分为哪几个模块</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668044711404.png" alt="1668044711404"></p>
<p><strong>掌握：</strong></p>
<p>日志接口是什么？常见的有几种形式？</p>
<p>日志接口是设计日志框架的一套标准，所有的日志框架都需要实现这些API接口。常见的形式有两种Commons Logging(JCL)和Simple Logging Facade for Java(SLF4J)</p>
<p>常见的日志实现框架有哪些？</p>
<p>JUL(java.util.logging)、Log4j、Logback</p>
<p>使用Logback至少需要使用哪几个模块？</p>
<p>Logback有logback-core和logback-classic以及logback-access三个模块，其中logback-core是基础模块，是必须要有的，logback-classic完整的实现了slf4jAPI是核心模块，Logback-access与Tomcat和Jetty等Servlet容器继承，提供HTTP访问日志的功能可以没有。</p>
<p>Logback日志框架至少需要整合三个模块：slf4j-api日志接口、logback-core、logback-classic</p>
<h3 id="3-3-Logback快速入门"><a href="#3-3-Logback快速入门" class="headerlink" title="3.3 Logback快速入门"></a>3.3 Logback快速入门</h3><p>快速使用一下Logback日志框架，使用Logback记录几条日志信息到文件中去和将日志信息打印在控制台上。</p>
<p>由于Logback是第三方提供的技术，所以首先需要将Jar包引入到项目中，具体步骤如下</p>
<ol>
<li><p>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code> 这三个jar包，复制一下</p>
</li>
<li><p>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</p>
</li>
<li><p>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</p>
</li>
<li><p>然后就可以开始写代码了，在代码中创建一个日志记录日对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建logback日志框架提供的logger日志对象，需要用LoggerFactory日志工厂调用getLogger()声明日志对象的名字。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;日志对象名字&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始记录日志，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBackTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Logger日志对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;LogBackTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//while (true) &#123;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法开始执行~~~&quot;</span>);</span><br><span class="line">                chu(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法执行成功~~~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;chu法方法执行失败了，出现了bug~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数a:&quot;</span> + a);</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数b:&quot;</span> + b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;结果是：&quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当我们运行程序时，就可以看到控制台记录的日志</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668045391911.png" alt="1668045391911"></p>
<p>同时在文件中，也有一份这样的日志信息。文件在哪里内，从配置文件中去找</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668045471304.png" alt="1668045471304"></p>
<p>打开<code>D:/log/itheima-data.log</code>看一下文件中是否有记录日志吧！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668045530645.png" alt="1668045530645"></p>
<p>再运行一次还会再下面继续记录，会一直往后走的。</p>
<h3 id="3-4-日志配置文件"><a href="#3-4-日志配置文件" class="headerlink" title="3.4 日志配置文件"></a>3.4 日志配置文件</h3><p>对Logback日志框架的控制，都是通过其核心配置文件logback.xml来实现的。</p>
<p>Logback提供了一个核心配置文件logback.xml，日志框架在记录日志时会读取配置文件中的配置信息，从而记录日志的形式。具体可以做哪些配置呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 可以配置日志输出的位置是文件、还是控制台</span><br><span class="line"><span class="number">2.</span> 可以配置日志输出的格式</span><br><span class="line"><span class="number">3.</span> 还可以配置日志关闭和开启、以及哪些日志输出哪些日志不输出。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如下图所示，控制日志往文件中输出，还是往控制台输出</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668045955362.png" alt="1668045955362"></p>
<ul>
<li><strong>如下图所示，控制打开和关闭日志</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668046078574.png" alt="1668046078574"></p>
<ul>
<li><p><strong>如下图所示，控制日志的输出的格式</strong></p>
<p>日志格式是由一些特殊的符号组成，可以根据需要删减不想看到的部分。比如不想看到线程名那就不要[%thread]。但是不建议同学们更改这些格式，因为这些都是日志很基本的信息。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668046216355.png" alt="1668046216355"></p>
<h3 id="3-5-配置日志级别-特别重要"><a href="#3-5-配置日志级别-特别重要" class="headerlink" title="3.5 配置日志级别(特别重要)"></a>3.5 配置日志级别(特别重要)</h3><p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668046420402.png" alt="1668046420402"></p>
<p>debug记录程序的执行信息</p>
<p>为什么要学习日志级别？</p>
<p>指导我们合理的输出日志级别，方便查询不同的日志信息。</p>
<p>一旦项目上线了，程序员为了方便定位问题，可能就不想向系统记录这些全部的日志级别信息。只想让系统记录info、warn、error这些日志不想记录debug这种日志级别。</p>
<ul>
<li>在哪里配置日志级别呢？如下图所示</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668046551345.png" alt="1668046551345"></p>
<ul>
<li><p>Logback只输出<strong>大于或者等于</strong>核心配置文件配置的日志级别信息。小于配置级别的日志信息，不被记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置的是trace，则trace、debug、info、warn、error级别的日志都被输出</span><br><span class="line">配置的是debug, 则debug、info、warn、error级别的日志被输出</span><br><span class="line">配置的是info,则info、warn、error级别的日志被输出</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>掌握:</strong></p>
<p>什么是日志级别？日志级别有哪些？</p>
<p>日志级别就是日志信息的类型，日志级别有：trace、debug、info、warn、error这五种类别</p>
<p>日志级别的作用是啥？</p>
<p>日志级别的就是方便程序员定位问题，日志信息比较多的时候还可以筛选出自己想要的日志级别的信息。</p>
<h2 id="四、多线程"><a href="#四、多线程" class="headerlink" title="四、多线程"></a>四、多线程</h2><p><strong>线程其实是程序中只有一条执行流程。</strong></p>
<p> 我们之前写过的程序，其实都是单线程程序，如下图代码，如果前面的for循环没有执行完，for循环下面的代码是不会执行的。</p>
<p>循环归根结底是由一条执行流程往前推进的，遇到循环只不过是多绕几个圈圈罢了，最后还是一条执行流程往前推进。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668046984412.png" alt="1668046984412"></p>
<p><strong>怎样的程序才是多线程程序呢？</strong> 如下图所示，12306网站就是支持多线程的，因为同时可以有很多人一起进入网站购票，而且每一个人互不影响。再比如百度网盘，可以同时下载和上传多个文件。这些程序中其实就有多条执行路径，每一条执行执行路径就是一条线程，所以这样的程序就是多线程程序。一句话来说，**多线程就是指的就是有多条执行流程在执行(多条线程由CPU负责调度执行)**。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668047091631.png" alt="1668047091631"></p>
<p>认识了什么是多线程程序，那如何使用Java创建线程呢？ Java提供了几种创建线程的方式，下一节再一种一种的学习。</p>
<h3 id="4-1-线程创建方式1"><a href="#4-1-线程创建方式1" class="headerlink" title="4.1 线程创建方式1"></a>4.1 线程创建方式1</h3><p>Java通过Java.lang.Thread类的对象来代表线程的，多个Thread对象代表多个线程。再去启动这些线程，这样程序中就有了多条线程了，创建线程并执行线程的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义一个子类继承Thread类，并重写run方法</span><br><span class="line"><span class="number">2.</span>创建Thread的子类对象</span><br><span class="line"><span class="number">3.</span>调用start方法启动线程（启动线程后，会自动执行run方法中的代码）</span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、让子类继承Thread线程类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写Thread类的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个测试类，在测试类中创建MyThread线程对象，并启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*目标：掌握线程的创建方式一:继承Thread类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="comment">// main方法是由一条默认的主线程负责执行。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建MyThread线程类的对象代表一个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">// 多态的写法</span></span><br><span class="line">        <span class="comment">// 4、启动线程（自动执行run方法的）</span></span><br><span class="line">        t.start();  <span class="comment">// main线程、t线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下图所示，我们会发现MyThread和main线程在相互抢夺CPU的执行权（<strong>注意：哪一个线程先执行，哪一个线程后执行，目前我们是无法控制的，每次输出结果都会不一样</strong>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668047848218.png" alt="1668047848218"></p>
<p>继承Thread类创建线程的对象的方法，优点是编码简单，缺点是线程类已经继承了Thread，无法继承其他类，不利于功能的扩展。</p>
<p><strong>最后我们还需要注意一点</strong>：</p>
<p>1、启动线程直接调用start方法而不是run方法。如果直接调用run方法把Thread当做一个普通的java对象，还是只有一条主线程往前推行，只有run方法执行完，再执行后面的。start方法就是向我们CPU注册这是一条单独的执行流程，CPU还是会去执行这个线程的run方法的，只有调用start方法才是启动一个新的线程执行。</p>
<p>2、不要把主线程任务放到启动子线程之前。不然永远等主线程跑完子线程才能跑，相当于单线程的效果。</p>
<p><strong>掌握：</strong></p>
<p>什么是多线程？线程的代表是谁？线程的创建方式一的具体步骤？</p>
<p>多线程就是指多条执行流程在执行，Java通过java.lang.Thread类的对象来代表线程。</p>
<p>线程的创建方式一是继承Thread类：</p>
<p>1、定义一个子类继承Thread类，并重写run方法</p>
<p>2、创建Thread的子类的对象</p>
<p>3、调用线程对象的start方法启动线程(启动线程后，会自动执行run方法中的代码)</p>
<p>线程的第一种创建方式有啥优缺点？</p>
<p>优点：编码简单</p>
<p>缺点：线程类已经继承了Thread了，无法继承其他的类，不利于功能扩展。</p>
<h3 id="4-2-线程的创建方式2"><a href="#4-2-线程的创建方式2" class="headerlink" title="4.2 线程的创建方式2"></a>4.2 线程的创建方式2</h3><p>线程的创建方式2：通过实现Runnable接口来创建线程</p>
<p>1、定义一个线程任务类MyRunnable来实现Runnable接口，重写接口里的run方法</p>
<p>2、得到线程的任务类后，可以创建MyRunnable任务对象。任务对象没有start方法。</p>
<p>3、把MyRunnable任务对象交给Thread处理，相当于得到了一个线程。</p>
<p>4、再调用线程对象的start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、定义一个任务类，实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 2、重写runnable的run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程要执行的任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握多线程的创建方式二：实现Runnable接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建任务对象。</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4、把任务对象交给一个线程对象处理。</span></span><br><span class="line">        <span class="comment">//  public Thread(Runnable target)</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出 ===》&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Runnable接口来创建线程</p>
<p>优点:任务类只是实现接口，可以继续继承其他类，实现其他接口，扩展性强。</p>
<p>缺点：需要多一个Runnable任务对象。</p>
<p><strong>掌握：</strong></p>
<p>线程创建方式二是如何创建线程的？</p>
<p>1、定义一个线程任务类MyRunnable来实现Runnable接口，重写接口里的run方法</p>
<p>2、得到线程的任务类后，可以创建MyRunnable任务对象。任务对象没有start方法。</p>
<p>3、把MyRunnable任务对象交给Thread处理，相当于得到了一个线程。</p>
<p>4、再调用线程对象的start()方法启动线程。</p>
<p>方式二的优缺点是什么？</p>
<p>优点:任务类只是实现接口，可以继续继承其他类，实现其他接口，扩展性强。</p>
<p>缺点：需要多一个Runnable任务对象。</p>
<p>线程创建方式二的另一种写法：匿名内部类的写法</p>
<p>1、创建Runnable接口的匿名内部类对象，这样就得到一个线程的任务类对象 。</p>
<p>2、再交给Thread线程对象</p>
<p>3、再调用线程对象的start()启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握多线程创建方式二的匿名内部类写法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、直接创建Runnable接口的匿名内部类形式（任务对象）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程1输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式1：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">// Runnable是函数式接口，可以用lambda表达式简化</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程2输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化形式2：</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程3输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程main输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-线程的创建方式3"><a href="#4-3-线程的创建方式3" class="headerlink" title="4.3 线程的创建方式3"></a>4.3 线程的创建方式3</h3><p>前面两种线程的创建方式都存在一个问题：</p>
<p>假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果。</p>
<p>怎么解决这个问题?</p>
<p>JDK5.0提供的Callable接口和FutureTask类来实现(多线程的第三种创建方式)</p>
<p>最大的优点：可以直接返回线程执行完毕后的结果</p>
<p>创建流程：</p>
<p>1、创建任务对象</p>
<p>定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。</p>
<p>把Callable类型的对象封装成FutureTask(线程任务对象)</p>
<p>2、把线程任务对象交给Thread对象</p>
<p>3、调用Thread对象的start方法启动线程</p>
<p>4、线程执行完毕后，通过FutureTask对象的get方法获取线程任务执行的结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240309174228132.png" alt="image-20240309174228132"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、让这个类实现Callable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 描述线程的任务，返回线程执行返回后的结果。</span></span><br><span class="line">        <span class="comment">// 需求：求1-n的和返回。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程求出了1-&quot;</span> + n + <span class="string">&quot;的和是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握线程的创建方式三：实现Callable接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3、创建一个Callable的对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 4、把Callable的对象封装成一个FutureTask对象（任务对象）</span></span><br><span class="line">        <span class="comment">// 未来任务对象的作用？</span></span><br><span class="line">        <span class="comment">// 1、是一个任务对象，实现了Runnable对象.</span></span><br><span class="line">        <span class="comment">// 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。</span></span><br><span class="line">        FutureTask&lt;String&gt; f1  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="comment">// 5、把任务对象交给一个Thread对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f1).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f2).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取线程执行完毕后返回的结果。</span></span><br><span class="line">        <span class="comment">// 注意：如果执行到这儿，假如上面的线程还没有执行完毕</span></span><br><span class="line">        <span class="comment">// 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> f1.get();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程创建方式三的优缺点：</p>
<p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果</p>
<p>缺点：编码复杂一点</p>
<h3 id="4-4-线程的常用方法"><a href="#4-4-线程的常用方法" class="headerlink" title="4.4 线程的常用方法"></a>4.4 线程的常用方法</h3><p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240309174625014.png" alt="image-20240309174625014"></p>
<p>下面我们演示一下<code>getName()</code>、<code>setName(String name)</code>、<code>currentThread()</code>、<code>sleep(long time)</code>这些方法的使用效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread_1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 哪个线程执行它，就拿到哪个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(t.getName()+ <span class="string">&quot;输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread_1</span>();</span><br><span class="line">        <span class="comment">// 为t1设置名字</span></span><br><span class="line">        t1.setName(<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 输出t1线程的名字，线程是默认有名字的，可以用setName()重置名字</span></span><br><span class="line">        System.out.println(t1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread_1</span>();</span><br><span class="line">        <span class="comment">// 为t2设置名字</span></span><br><span class="line">        t2.setName(<span class="string">&quot;2号线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 输出t2线程的名字</span></span><br><span class="line">        System.out.println(t2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取主线程对象的名字，不能直接拿到它的名字，主线程是系统创建的，不是我们自己创建的</span></span><br><span class="line">        <span class="comment">// currentThread()方法用于获取当前执行的线程,主线程会一直往下走，所以到这的就是主线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        m.setName(<span class="string">&quot;最牛的线程&quot;</span>);</span><br><span class="line">        System.out.println(m.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(m.getName()+ <span class="string">&quot;输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Thread提供了有参构造器public Thread(String name)它是可以直接在用构造器的时候为线程取一个名字。这样就不用调用set方法多</p>
<p>一行代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 为当前线程设置名字了,MyThread构造器接到名字后，传给父类Thread方法，因为Thread默认有有参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 哪个线程执行它，它就会得到哪个线程对象。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot;输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Thread的常用方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">        <span class="comment">// t1.setName(&quot;1号线程&quot;);</span></span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(t1.getName()); <span class="comment">// Thread-0</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号线程&quot;</span>);</span><br><span class="line">        <span class="comment">// t2.setName(&quot;2号线程&quot;);</span></span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(t2.getName()); <span class="comment">// Thread-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程对象的名字，不能直接拿到主线程的对象，因为主线程是官方默认的</span></span><br><span class="line">        <span class="comment">// 哪个线程执行它，它就会得到哪个线程对象。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        m.setName(<span class="string">&quot;最牛的线程&quot;</span>);</span><br><span class="line">        System.out.println(m.getName()); <span class="comment">// main</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(m.getName() + <span class="string">&quot;线程输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/1668052028054.png" alt="1668052028054"></p>
<p><strong>最后再演示一下sleep和join这两个方法是什么效果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握sleep方法,join方法的作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="comment">// 休眠5s</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">// 会让当前执行的线程暂停5秒，再继续执行</span></span><br><span class="line">                <span class="comment">// 项目经理让我加上这行代码，如果用户交钱了，我就注释掉！</span></span><br><span class="line">                 Thread.sleep(<span class="number">5000</span>); <span class="comment">// 毫秒的意思</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join方法作用：让当前调用这个方法的线程先执行完。</span></span><br><span class="line">        <span class="comment">// 面试题：有三个线程如何保证t1跑完，t2再跑完，最后t3跑完。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">        t1.start(); <span class="comment">// t1执行完才能往下走</span></span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;3号线程&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t3.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311165310156.png" alt="image-20240311165310156"></p>
<h3 id="4-5-线程安全问题-很重要"><a href="#4-5-线程安全问题-很重要" class="headerlink" title="4.5 线程安全问题(很重要)"></a>4.5 线程安全问题(很重要)</h3><h4 id="4-5-1-什么是线程安全问题？"><a href="#4-5-1-什么是线程安全问题？" class="headerlink" title="4.5.1 什么是线程安全问题？"></a>4.5.1 什么是线程安全问题？</h4><p>多个线程，同时操作同一共享资源的时候，可能会出现业务安全问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311165521277.png" alt="image-20240311165521277"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311165803965.png" alt="image-20240311165803965"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311165652210.png" alt="image-20240311165652210"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311165725928.png" alt="image-20240311165725928"></p>
<p>线程安全问题出现的原因？</p>
<p>1、存在多个线程在执行</p>
<p>2、同时访问一个共享资源</p>
<p>3、存在修改该共享资源</p>
<h4 id="4-5-2-用程序模拟线程安全问题"><a href="#4-5-2-用程序模拟线程安全问题" class="headerlink" title="4.5.2 用程序模拟线程安全问题"></a>4.5.2 用程序模拟线程安全问题</h4><p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311170507426.png" alt="image-20240311170507426"></p>
<p>新建一个账户类，代表两人的共享账户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId; <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在账户中设计一个取钱方法，可以用对象调用该方法取钱。小明 小红同时过来的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？在创建线程对象的时候，可以为线程设计一个名字。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个线程，去同一个账户中取钱10万。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 2、定义一个成员变量，让run方法能对这个账户取钱</span></span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="comment">// 1、提供一个有参构造器来接账户对象和线程名字，这样能分清楚谁在取钱。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用Thread提供的有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 取钱(小明，小红)</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：模拟线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// 1、创建一个账户对象，代表两个人的共享账户。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-110&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 2、创建两个线程，分别代表小明 小红，再去同一个账户对象中取钱10万。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start(); <span class="comment">// 小明</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start(); <span class="comment">// 小红</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311171947718.png" alt="image-20240311171947718"></p>
<p>线程安全问题发生的原因，总结就一句话：多个线程，同时访问同一个共享资源，且存在修改该资源。</p>
<h3 id="4-6-线程同步"><a href="#4-6-线程同步" class="headerlink" title="4.6 线程同步"></a>4.6 线程同步</h3><p>线程同步是什么？</p>
<p>解决线程安全问题的方案。</p>
<p>线程同步的思想？</p>
<p>让多个线程先后依次访问共享资源，这样就解决了安全问题。</p>
<p>线程同步的常见方案：</p>
<p>加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他进程才能再加锁进来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311172749078.png" alt="image-20240311172749078"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311172941036.png" alt="image-20240311172941036"></p>
<p>加锁的实现方案：</p>
<p>1、同步代码块</p>
<p>2、同步方法</p>
<p>3、Lock锁</p>
<h4 id="4-6-1-同步代码块"><a href="#4-6-1-同步代码块" class="headerlink" title="4.6.1 同步代码块"></a>4.6.1 同步代码块</h4><p>作用：把访问共享资源的核心代码上锁，一次保证线程安全。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311173321251.png" alt="image-20240311173321251"></p>
<p>这个同步锁说白了就是Java对象，来代表一把锁。</p>
<p>原理：每次只允许一个线程加锁后进入。执行完毕后自动解锁，其他线程才可以进来执行。</p>
<p>同步锁的注意事项：</p>
<p>对于当前同时执行的线程来说，同步锁必须是同一把(同一个对象)，否则会出bug。</p>
<p>就像家里的大门，大门上的一把锁对于全家所有人来说都是同一把锁。</p>
<p>同步代码块的第一步：需要先找到访问共享资源的核心代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码块是Account类中的取钱操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="string">&quot;黑马&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步锁对于不同的线程来说必须是同一个对象才行，我们可以随便写个字符串对象，由于字符串对象存放在常量池中，在计算机中只有一份。</span><br><span class="line">对于小明和小红对象是同一份，当然可以锁住小明和小红线程，只允许一个线程进来。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311180511416.png" alt="image-20240311180511416"></p>
<p>同步代码块使用的重要的注意事项：</p>
<p>我们现在的锁对象用的是任意的唯一对象，这会有一些问题。</p>
<p>如果现在取钱的有两家人，也就是有两个账户对象。分别取各自家里的钱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：模拟线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-110&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start(); <span class="comment">// 小明</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start(); <span class="comment">// 小红</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-112&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc1, <span class="string">&quot;小黑&quot;</span>).start(); <span class="comment">// 小黑</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc1, <span class="string">&quot;小白&quot;</span>).start(); <span class="comment">// 小白</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用的锁对象是字符串，他在系统中永远只有一份。这个对象对于小明、小红、小黑、小白都是同一个对象。这样小明过来不仅能锁住小红还能锁住小黑小白。我们应该用他们彼此的共享资源来作为锁，可以用this作为锁，this刚好能代表这个账户的共享资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId; <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Account.class)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明 小红线程同时过来的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">        <span class="comment">// this正好代表共享资源！</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在开发的时候也可能会遇到多线程调用静态方法的情况，在这里面用锁的话，官方建议使用类名.class，它是一个字节码，可以理解成class文件，class文件在系统中只有一份。为什么静态方法此时建议使用class作为锁呢？静态方法就是所有对象通过类名进行访问的，我要锁住所有的对象，只能用类名.class。锁住当前访问这个静态方法的所有进程，只允许一个线程进来。所有静态方法使用类名.class作为锁很合理，它可以锁住当前使用类名访问这个静态方法的所有进程的。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Account.class)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>1、同步代码块是如何实现线程安全的？</p>
<p>同步代码块通过对共享资源的核心代码使用synchronized(同步锁)这个同步代码块来锁住线程，每次只允许一个线程进入。</p>
<p>2、锁对象随便选择一个唯一的对象好不好？</p>
<p>不好，会影响其他无关线程。</p>
<p>3、锁对象的使用规范？</p>
<p>建议使用<strong>共享资源</strong>作为锁对象，对于实例方法建议使用this作为锁对象，静态方法使用字节码(类名.class)对象作为锁对象。</p>
<h4 id="4-6-2-同步方法"><a href="#4-6-2-同步方法" class="headerlink" title="4.6.2 同步方法"></a>4.6.2 同步方法</h4><p>作用：把访问共享资源的核心方法给上锁，以此保证线程安全。</p>
<p>只需要在方法的前面加上synchronized关键字来修饰，这个方法就上锁了。</p>
<p>原理：每次只能允许一个线程加锁进入，执行完毕后自动解锁，其他线程才可以进来执行。</p>
<p>同步方法要求我们首先找到访问共享资源的核心方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId; <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明 小红线程同时过来的</span></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="comment">// synchronized代码块在执行完成之后会自动唤醒所有被该放方法所阻塞的线程 notifyall()</span></span><br><span class="line">    <span class="comment">// 也在代码中通过线程去手动调用 提前唤醒阻塞线程 或调用wait()来将自己阻塞起来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>1、同步方法是如何保证线程安全的？</p>
<p>同步方法在共享资源的核心方法外面加上<strong>synchronized关键字</strong>来修饰，每次只能允许一个线程加锁进入，执行完毕后自动解锁，其他线程才可以进来执行。</p>
<p>2、同步方法同步锁对象的原理？</p>
<p>同步方法的底层是有<strong>隐式锁对象</strong>的，它会把整个方法上锁。如果方法是<strong>实例方法</strong>的话，同步方法默认使用<strong>this</strong>作为锁对象。如果是<strong>静态方法</strong>会默认使用<strong>类名.class</strong>作为锁对象。</p>
<p>3、同步代码块好还是同步方法好？</p>
<p>从范围上来看，<strong>同步代码块锁的范围更小，同步方法锁的范围更大</strong>。</p>
<p><strong>锁的范围越小其实它的性能越好</strong>，锁的范围小的话所有的线程都可以先把这个方法加载了，先把锁前面的代码执行了，所有的线程都可以一块做完。等到同步锁的时候才开始排队，这样的话上面的代码一起跑完性能肯定会更好。同步方法锁的范围比较大，这就会导致线程在方法外面排队，一个线程执行完了另外的线程还需要先加载方法才能执行。</p>
<p>这点性能对计算机来说不会过多的当回事，<strong>一般还是使用同步方法，同步方法的可读性更好一些</strong>。</p>
<h4 id="4-6-3-Lock锁"><a href="#4-6-3-Lock锁" class="headerlink" title="4.6.3 Lock锁"></a>4.6.3 Lock锁</h4><p>同步代码块和同步方法的共同特点就是提供一个所谓的对象来代表锁，程序会自动加锁和解锁以便保证线程安全。</p>
<p>Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建锁对象进行加锁和解锁，更灵活，更方便，更强大。</p>
<p>Lock锁是一个接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311215343966.png" alt="image-20240311215343966"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311215401239.png" alt="image-20240311215401239"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId; <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明 小红线程同时过来的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lk.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lk.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建了锁对象时，定义成一个实例对象。这样在创建账户的时候，也会创建属于这个账户的唯一锁对象出来。</span><br><span class="line">一个账户对象会有一个锁对象,锁对象前面建议用final修饰，表示锁对象是不能被替换的，对锁对象进行保护。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加锁的时候注意，如果加锁和解锁之间的代码出现异常，那么就会跳走了，解锁的操作会导致没机会执行，其他线程就进不来了。我们要保证即便中间出现问题的话也应该进行解锁操作，所以这段代码放在try-catch-finally中比较好。这样解锁操作放在finally里，即便中间操作出现异常被拦截之后最终还是可以解锁，这样比较安全。</span><br></pre></td></tr></table></figure>

<h3 id="4-7-线程通信-了解"><a href="#4-7-线程通信-了解" class="headerlink" title="4.7 线程通信(了解)"></a>4.7 线程通信(了解)</h3><p>什么是线程通信？</p>
<p>当多个线程共同操作共享资源的时候，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺。</p>
<p>线程通信常见模型(生产者与消费者模型)</p>
<p>生产者线程负责生产数据</p>
<p>消费者线程负责消费生产者生产的数据</p>
<p>注意：生产者生产完数据应该等待自己，通知消费者消费；消费者消费完数据也应该等待自己，再通知生产者生产！</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240311225649288.png" alt="image-20240311225649288"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放1个包子的方法</span></span><br><span class="line">    <span class="comment">// 厨师1 厨师2 厨师3</span></span><br><span class="line">    <span class="comment">// synchronized代码块在执行完成之后会自动唤醒所有被该放方法所阻塞的线程 notifyall()</span></span><br><span class="line">    <span class="comment">// 也在代码中通过线程去手动调用 提前唤醒阻塞线程 或调用wait()来将自己阻塞起来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">// 判断是否有包子。</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(name + <span class="string">&quot;做的肉包子&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;做了一个肉包子~~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有包子了，不做了。</span></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 吃货1 吃货2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 有包子，吃了</span></span><br><span class="line">                System.out.println(name  + <span class="string">&quot;吃了：&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line">                list.clear();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有包子</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">锁是可以跨方法的，这两个方法可以用同一把锁，这样一把锁就锁定了5个线程对象，每次只有一个线程能抢到桌子对象然后进来访问，这样就控制5个线程访问桌子是线程安全的。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：了解一下线程通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//   需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上</span></span><br><span class="line">        <span class="comment">//      2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。</span></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Runnable创建线程对象,可以写成lambda表达式的形式</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建3个生产者线程（3个厨师）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建2个消费者线程（2个吃货）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312012102962.png" alt="image-20240312012102962"></p>
<p>上述方法一定要用<strong>当前同步锁对象调用</strong>，否则一定会出bug的。</p>
<p>只有锁对象知道谁占据了它，谁在等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放1个包子的方法</span></span><br><span class="line">    <span class="comment">// 厨师1 厨师2 厨师3</span></span><br><span class="line">    <span class="comment">// synchronized代码块在执行完成之后会自动唤醒所有被该放方法所阻塞的线程 </span></span><br><span class="line">    <span class="comment">// notifyAll()方法是在代码中通过线程去手动调用，提前唤醒阻塞线程</span></span><br><span class="line">    <span class="comment">// wait()来将自己阻塞起来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 知道是哪个厨师进来了，拿到他的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">// 判断是否有包子。</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(name + <span class="string">&quot;做的肉包子&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;做了一个肉包子~~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有包子了，不做了。</span></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 吃货1 吃货2</span></span><br><span class="line">    <span class="comment">// 总会有吃货抢到锁的时候</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 有包子，吃了</span></span><br><span class="line">                System.out.println(name  + <span class="string">&quot;吃了：&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line">                list.clear();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有包子</span></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312013215046.png" alt="image-20240312013215046"></p>
<blockquote>
<p>线程通信有个观点，他把这个事情做完了，不能再继续做了，此时他要等待自己并唤醒别人。自己不再去竞争CPU资源(同步锁)，把自己暂停起来。把锁给别人，提高性能。但是一定是唤醒别人在前面，等待自己在后面。</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>线程通信的三个常见方法？</p>
<p>wait()：让当前线程等待并释放所占的锁，直到另一个线程调用notify()或者notifyAll()方法。</p>
<p>notify(): 唤醒正在等待的单个线程</p>
<p>notifyAll(): 唤醒正在等待的所有线程</p>
<h3 id="4-8-线程池"><a href="#4-8-线程池" class="headerlink" title="4.8 线程池"></a>4.8 线程池</h3><h4 id="4-8-1-什么是线程池？"><a href="#4-8-1-什么是线程池？" class="headerlink" title="4.8.1 什么是线程池？"></a>4.8.1 什么是线程池？</h4><p>线程池是一种可以复用线程的技术。</p>
<p>比如，可以在系统中创建三个线程，这三个线程处理完任务后，可以继续复用这些线程去处理其他任务。也就是说这三个线程可以长久的存活，被我们重复的利用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312021358672.png" alt="image-20240312021358672"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312021454760.png" alt="image-20240312021454760"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312022726971.png" alt="image-20240312022726971"></p>
<p>如果线程池里固定的线程数是三个的话，用户发起任务，就会出现一个线程来处理任务。当三个任务都被线程处理着，此时再来任务就会进入队列排队。等前面线程处理完任务，腾出手来才能处理后面的任务。</p>
<p><strong>本质就是复用这些线程去处理很多任务</strong>，我们将这些线程称为<strong>工作线程</strong>也成为<strong>核心线程</strong>，这些核心线程是固定数量可以重复利用的。下面的称任务队列，这个任务队列就是放这些线程需要处理的任务的。这些任务是一个对象，它们必须实现Runnable接口和Callable接口才能称为任务对象，才能进入任务队列被处理。</p>
<p>线程池就是可以控制线程的数量，重复利用这些线程去处理任务。同时还能控制任务的数量，把这些任务暂时缓存起来。由于线程池既可以控制线程的数量又可以控制任务的数量，因此，他不会因为这些线程过多或者任务过多导致把系统资源耗尽引起系统瘫痪的风险，整体来看可以提高系统的整体性能。</p>
<h4 id="4-8-2-如何创建线程池？-重点"><a href="#4-8-2-如何创建线程池？-重点" class="headerlink" title="4.8.2 如何创建线程池？(重点)"></a>4.8.2 如何创建线程池？(重点)</h4><p>谁代表线程池？</p>
<p>JDK 5.0起提供了代表线程池的接口：ExecutorService</p>
<p>它只是规定了线程池要具备的基本功能，比如处理任务等等，但是接口不能直接创建对象来代表线程池的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312142144985.png" alt="image-20240312142144985"></p>
<p>这七个参数是重点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312142947556.png" alt="image-20240312142947556"></p>
<p>maximumPoolSize: 最大线程数量是5，核心线程数量是3，代表最大可创建两个临时线程。</p>
<p>keepAliveTime: 临时线程空闲了多长时间没事干，就会把它干掉。</p>
<p>threadFactory: 线程工厂就是来创建核心线程或者临时线程的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试热点问题：</p>
<p>1、临时线程什么时候创建？</p>
<p>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，才是才会创建临时线程。</p>
<p>2、什么时候开始拒绝新任务？</p>
<p>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务。</p>
<p>3、谁代表线程池？创建线程池的方案有几种？</p>
<p>ExecutorService代表线程池的接口。有两种方案。第一种：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象。</p>
<p>4、ThreadPoolExcutor实现线程池对象的七个参数是什么意思？</p>
<p>corePoolSize: 代表核心线程数量</p>
<p>maximumPoolSize:代表线程最大数量</p>
<p>KeepAliveTime:临时线程存活时间</p>
<p>unit：线程存活时间单位</p>
<p>workQueue：任务队列</p>
<p>threadFactory：线程池工厂</p>
<p>handle：线程池任务拒绝策略</p>
<h4 id="4-8-3-使用线程池处理Runnable任务"><a href="#4-8-3-使用线程池处理Runnable任务" class="headerlink" title="4.8.3 使用线程池处理Runnable任务"></a>4.8.3 使用线程池处理Runnable任务</h4><p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312145001678.png" alt="image-20240312145001678"></p>
<p>要处理Runnable任务，首先我们先定义Runnable任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 任务是干啥的？</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ==&gt; 输出666~~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用线程池来处理任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握线程池的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312145739796.png" alt="image-20240312145739796"></p>
<p>运行结束，线程池还是没有死亡的，线程池中的线程是要长久存活的。</p>
<p>如果想让其死亡，可以手动停止，或者使用shutdown这个API，这个方法可以等前面任务都执行完成后再关闭。shutdownNow可以立即把线程关掉，即使线程池中的任务没有执行完，关掉之后会返回没有执行完的任务。</p>
<p>使用shutdown关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">         pool.shutdown(); <span class="comment">// 等着线程池的任务全部执行完毕后，再关闭线程池</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312150337640.png" alt="image-20240312150337640"></p>
<p>使用shutdownNow关闭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        pool.shutdownNow(); <span class="comment">// 立即关闭线程池！不管任务是否执行完毕！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312150509115.png" alt="image-20240312150509115"></p>
<p>前面三个任务执行完了，它会直接执行到shutdownNow，剩余的两个任务还有可能没有执行完。</p>
<p>一般不用关闭线程池，关闭的话用的多的还是shutdown。</p>
<p>什么时候会创建临时线程？</p>
<p>当三个核心线程都在忙，任务队列中的四个位置都满了。等到新任务过来的时候才会创建临时线程。</p>
<p>怎么让上面三个任务都忙？</p>
<p>每个任务执行核心线程的时候，让休眠时间变成最大的整型值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 任务是干啥的？</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ==&gt; 输出666~~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当任务队列有四个任务排队的时候，还不会创建新的临时线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312151349411.png" alt="image-20240312151349411"></p>
<p>再加一个任务，就满足核心线程都在忙，任务队列四个位置都满了的情况，这时会创建临时线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了临时线程的创建时机了</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312151639669.png" alt="image-20240312151639669"></p>
<p>再加任务也会创建临时线程，因为可以创建两个临时线程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312151801766.png" alt="image-20240312151801766"></p>
<p>如果三个核心线程在忙，两个临时线程也在忙，任务队列的四个位置都满了，再来新任务的时候就到了新任务拒绝的时机了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312153041707.png" alt="image-20240312153041707"></p>
<p>如果用AbortPolicy()策略的话会直接抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.AbortPolicyPolicy() 直接抛异常,拒绝任务.</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了临时线程的创建时机了</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">         <span class="comment">//pool.shutdown(); // 等着线程池的任务全部执行完毕后，再关闭线程池</span></span><br><span class="line"><span class="comment">//         pool.shutdownNow(); // 立即关闭线程池！不管任务是否执行完毕！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312152556659.png" alt="image-20240312152556659"></p>
<p>如果用CallerRunsPolicy()策略的话，它会由主线程负责调用任务的run方法，从而绕过线程池直接执行。就相当于由老板亲自出来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了临时线程的创建时机了</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">         <span class="comment">//pool.shutdown(); // 等着线程池的任务全部执行完毕后，再关闭线程池</span></span><br><span class="line"><span class="comment">//         pool.shutdownNow(); // 立即关闭线程池！不管任务是否执行完毕！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312152722914.png" alt="image-20240312152722914"></p>
<p>DiscardPolicy()这个异常处理的方法，会丢弃任务，不抛异常，不推荐使用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了临时线程的创建时机了</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">         <span class="comment">//pool.shutdown(); // 等着线程池的任务全部执行完毕后，再关闭线程池</span></span><br><span class="line"><span class="comment">//         pool.shutdownNow(); // 立即关闭线程池！不管任务是否执行完毕！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312220416143.png" alt="image-20240312220416143"></p>
<p>DiscardOldestPolicy()这个异常处理方法，抛弃队列中等待最久的任务，然后把当前任务加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="comment">// Executors.defaultThreadFactory()获取一个默认的线程池工厂</span></span><br><span class="line">        <span class="comment">// ThreadPoolExecutor.CallerRunsPolicy() 告诉新任务没办法处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了临时线程的创建时机了</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        <span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">         <span class="comment">//pool.shutdown(); // 等着线程池的任务全部执行完毕后，再关闭线程池</span></span><br><span class="line"><span class="comment">//         pool.shutdownNow(); // 立即关闭线程池！不管任务是否执行完毕！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312220706239.png" alt="image-20240312220706239"></p>
<h4 id="4-8-4-使用线程池处理Callable任务"><a href="#4-8-4-使用线程池处理Callable任务" class="headerlink" title="4.8.4 使用线程池处理Callable任务"></a>4.8.4 使用线程池处理Callable任务</h4><p>当线程池处理完这个任务过后，是可以返回处理后的结果的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312221244144.png" alt="image-20240312221244144"></p>
<p>把Callable任务交给submit方法的时候，它会返回一个未来对象任务给我们。到时候我们可以通过Future对象去获取我们的线程池处理完任务返回后的结果。</p>
<p>首先创建Callable线程对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、让这个类实现Callable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 描述线程的任务，返回线程执行返回后的结果。</span></span><br><span class="line">        <span class="comment">// 需求：求1-n的和返回。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;求出了1-&quot;</span> + n + <span class="string">&quot;的和是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握线程池的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。到时候会通过未来任务对象调用get方法，获取线程执行完毕后的结果。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312221822464.png" alt="image-20240312221822464"></p>
<p>我们可以看出计算1-400的和的时候，复用了前面的线程对象2。</p>
<p><strong>问题：</strong></p>
<p>线程池如何处理Callable任务，并得到任务执行完后返回的结果？</p>
<p>线程池通过调用submit方法来处理Callable任务对象，submit方法会返回一个Future对象，通过未来对象调用其get方法，可以获得任务执行后的结果。</p>
<h4 id="4-8-5-通过Executors来创建线程池"><a href="#4-8-5-通过Executors来创建线程池" class="headerlink" title="4.8.5 通过Executors来创建线程池"></a>4.8.5 通过Executors来创建线程池</h4><p>Executors是线程的一个工具类，提供了很多静态方法用于返回不同特点的线程池对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312222512654.png" alt="image-20240312222512654"></p>
<p>这些方法的底层都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象。</p>
<p>newFixedThreadPool底层是ThredPoolExecutor实现的，它的核心线程数量核最大线程数量是一样的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312225053384.png" alt="image-20240312225053384"></p>
<p>newSingleThreadExecutor底层也是ThreadPoolExecutor，它的核心线程核最大线程是1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312225416573.png" alt="image-20240312225416573"></p>
<p>通过newFixedThreadPool来创建线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握线程池的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line"><span class="comment">//        ExecutorService pool = new ThreadPoolExecutor(3, 5, 8,</span></span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), Executors.defaultThreadFactory(),</span></span><br><span class="line"><span class="comment">//                new ThreadPoolExecutor.CallerRunsPolicy());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1-2 通过Executors创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 老师：核心线程数量到底配置多少呢？？？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312223115289.png" alt="image-20240312223115289"></p>
<p>1-400的求和又调用了2号线程，代表实现类线程的复用。</p>
<p>核心线程数量到底配置多少呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算密集型的任务：核心线程数量 = CPU的核数 + <span class="number">1</span></span><br><span class="line">IO密集型的任务：核心线程数量 = CPU核数 * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>使用ctrl+alt+delete调出任务管理器，性能里有CPU的核数。6核12个逻辑处理器，计算密集型线程数应配置成13</p>
<p><strong>Executors类的特别注意事项：</strong></p>
<p>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</p>
<p>大型并发系统就比如京东淘宝这些，每次有几千上万的用户访问。</p>
<p>Java开发手册上说明了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312224833824.png" alt="image-20240312224833824"></p>
<p><strong>总结：</strong></p>
<p>1、Executors工具类的底层是基于什么方式实现的线程池对象？</p>
<p>底层还是通过ThreadPoolExecutor这个线程实现类。</p>
<p>2、Executors是否适合做大型互联网场景的线程池方案？</p>
<p>不适合，用Executors做大型互联网场景的线程池方案容易导致资源不足。还是得用ThreadPoolExecutor来实现。</p>
<p>FixedThreadPool和SignalThreadPool只限制了创建线程的数量，却没用限制请求队列的长度，所以可能会堆积大量请求，导致内存溢出。CachedThreadPool可能会创建大量的线程，导致内存溢出</p>
<h3 id="4-9-并发和并行"><a href="#4-9-并发和并行" class="headerlink" title="4.9 并发和并行"></a>4.9 并发和并行</h3><p>什么是进程？</p>
<p>正在运行的程序(软件)就是一个独立的进程。</p>
<p>线程是属于进程的，一个进程中可以同时运行很多个线程。</p>
<p>比如百度网盘这个进程里面，有的线程负责上传文件，有的线程负责下载文件。</p>
<p><strong>进程中的多个线程其实是并发和并行执行的。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312230911294.png" alt="image-20240312230911294"></p>
<p>并行：同一时刻上，同时又很多线程被CPU带哦都执行</p>
<p>电脑的内核是6个，由于是双核的，加起来就是12个处理器，所以本地电脑CPU同时可以并行16个线程。</p>
<p>多线程是怎么执行的？</p>
<p>并发和并行同时进行的！</p>
<h3 id="4-10-线程的生命周期"><a href="#4-10-线程的生命周期" class="headerlink" title="4.10 线程的生命周期"></a>4.10 线程的生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312231544504.png" alt="image-20240312231544504"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312231636853.png" alt="image-20240312231636853"></p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312232922474.png" alt="image-20240312232922474"></p>
<p><strong>流程：</strong></p>
<p>线程被创建后，调用start方法变成可运行状态，执行完毕或者出现异常会进入终止状态。</p>
<p>如果线程进入到了可运行状态后没有抢到锁对象就会进入阻塞状态，等到获得锁对象后会恢复成可运行状态。</p>
<p>线程进入可运行状态后，获得锁对象，然后调用了wait()无参的方法会进入无线等待的状态。如果在无线等待状态被其他线程notify，但是没有获得锁对象会进去阻塞状态，如果在无线等待状态被其他线程notify并获得锁对象就会回到可运行状态。</p>
<p>线程进入可运行状态后，如果调用了sleep方法或者wait()有参方法，会进入计时等待状态。其中sleep是不会释放锁的，一旦时间到会立刻回到可运行状态，当wait时间到并获得锁对象，或者时间没到但是被其他线程notify了并获得锁对象，也会回到可运行状态。但是wait时间到了未获得锁，或者wait时间没到被其他线程notify了也没获得锁对象，此时会进入阻塞状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240312233146302.png" alt="image-20240312233146302"></p>
<h3 id="4-11-乐观锁-面试常问"><a href="#4-11-乐观锁-面试常问" class="headerlink" title="4.11 乐观锁(面试常问)"></a>4.11 乐观锁(面试常问)</h3><p>假如又要线程安全，又要同时执行怎么办？</p>
<p>使用乐观锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">悲观锁：一上来就加锁，没有安全感。每次只能一个线程进入访问完毕后，再解锁。 线程安全，性能较差!</span><br><span class="line">乐观锁：一开始不上锁，认为没有问题，大家一起跑，等要出现线程安全问题的时候才开始控制。线程安全，性能较好。</span><br></pre></td></tr></table></figure>

<p>通过一个案例来理解乐观锁：</p>
<p>需求：1个变量，100个线程，每个线程对其加100次</p>
<p>首先创建一个Runnable的实现类，在Runnable类中定义一个变量，由于只有一个类，则变量时唯一的，用于记录访问量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count ======&gt;&quot;</span> + ++count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建一个Runnable的目标对象，用其创建100个线程对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：拓展悲观锁、乐观锁原理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求：1个变量，100个线程，每个线程对其加100次</span></span><br><span class="line">        <span class="comment">// 1、创建一个Runnable目标对象，用于实现加100次</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//2、创建100个线程对象,并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240313134102197.png" alt="image-20240313134102197"></p>
<p>访问量应该到达10000，但是执行结果却只到达了9999。</p>
<p>如果现在count值是10，有两个线程竞争这个count，那么两个线程同时拿出这个10再加上1，然后都将11放回去。那么这样就出现了少加1次的情况。所以会产生安全问题，这就是多个线程访问同一个共享资源出现安全问题。</p>
<p>怎么解决这个安全问题？</p>
<p>第一种，加悲观锁，每次只允许一个线程操作它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// this 代表MyRunnable这个类的对象，这个类的对象只用了一个</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                        <span class="string">&quot;count ======&gt;&quot;</span> + ++count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240313135300420.png" alt="image-20240313135300420"></p>
<p>执行结果没问题，它是一直往前加的，但是哪个线程加的就不一定了。</p>
<p>虽然，没用悲观锁会出现线程安全，但是每次执行结果都接近线程安全。这说明100个线程在改这个变量的时候，冲突的机会是比较少的。出现线程安全的问题不是很高，由于计算机的速度很快，每个线程执行完成都有先后，可能它正好改完下一个才来。</p>
<p>所以由于出错的概率很低，索性不加锁。</p>
<p>CAS(比较修改算法)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240313140436126.png" alt="image-20240313140436126"></p>
<p>如果线程将10拿出来改成11，再次回去发现还是原来的10，证明没有其他的线程修改，那么就认为线程安全。</p>
<p>如果线程拿出10的时候，已经有线程也拿出10修改成11放回去了，那么等他回来的时候发现这个值已经不是原来的10了，就认为出现了线程安全，于是就将这次的修改作废，再重新拿11。由于加锁的代价比较大，不加锁它的性能会好一些。</p>
<p>整数修改的乐观锁：原子类实现，AtomicInteger，底层是比较修改算法CAS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 原子类的incrementAndGet()方法，把底层值取出加1再展示，就相当于先++count再返回。这个方法内部没有加锁，内部就                是基于原子类实现的</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                        <span class="string">&quot;count ======&gt;&quot;</span> + count.incrementAndGet());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-12-多线程题"><a href="#4-12-多线程题" class="headerlink" title="4.12 多线程题"></a>4.12 多线程题</h3><p><img src="https://cdn.jsdelivr.net/gh/9527haoyunlai/PicGo/images/JavaSE/image-20240313145744939.png" alt="image-20240313145744939"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sendThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于静态变量属于这个类的，而且gift集合是唯一的，所以用private修饰</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; gift;</span><br><span class="line">    <span class="comment">// 由于count是实例变量属于线程对象的，小红和小明对象各有自己的count。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建有参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">sendThread</span><span class="params">(List&lt;String&gt; gift, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.gift =gift;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// run方法实现发送礼物,会出现线程安全，当两个人同时发一个包包。</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 死循环应该放到锁的外面，每次发礼物都要去抢锁，不然一个线程抢到锁之后，会直接将礼物发完。</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">             <span class="comment">// 注意1：锁对象必须唯一</span></span><br><span class="line">            <span class="comment">// 不能用this来作为锁对象，因为this不唯一。创建了两个线程对象小红和小明，this代表类的对象，小明和小红是两个类对             // 象。可以用gift做锁，集合gift只有一个。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (gift)&#123;</span><br><span class="line">                <span class="keyword">if</span>(gift.size() &lt;<span class="number">10</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能直接用get,取出后还得删除所以用remove</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> gift.remove(r.nextInt(gift.size()));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;发出了:&quot;</span>+ rs);</span><br><span class="line">                <span class="comment">// 还需要统计发送了多少个,每个线程对象加自己的count</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用get方法拿count值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 目标：有100份礼物，小红和小明同时发送礼物，当剩下的礼物小于10的时候停止发送，求下小明和小红各自发了多少礼物</span></span><br><span class="line">        <span class="comment">// 用多线程进行模拟</span></span><br><span class="line">        <span class="comment">// 1、定义一个集合，存放100个礼物</span></span><br><span class="line">        List&lt;String&gt; gift = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] giftName =&#123;<span class="string">&quot;包包&quot;</span>,<span class="string">&quot;鞋子&quot;</span>,<span class="string">&quot;口红&quot;</span>,<span class="string">&quot;腰带&quot;</span>,<span class="string">&quot;项链&quot;</span>,<span class="string">&quot;剃须刀&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            gift.add(giftName[r.nextInt(giftName.length)]+ (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(gift);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、定义线程类创建线程对象,去集合中拿礼物给别人</span></span><br><span class="line">        <span class="type">sendThread</span> <span class="variable">xh</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">sendThread</span>(gift,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        xh.start();</span><br><span class="line">        <span class="type">sendThread</span> <span class="variable">xm</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">sendThread</span>(gift,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        xm.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程往下走的时候，这两个线程对象还有可能没有跑完，我们此时取count的值会出错，所以用join()方法。</span></span><br><span class="line">        <span class="comment">// 调用join方法，保证小明跑完了小红才能跑完，然后主线程才能往下走。在这用sleep睡一会不靠谱。</span></span><br><span class="line">        xh.join();</span><br><span class="line">        xm.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;小红发出去了:&quot;</span>+ xh.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;小明发出去了&quot;</span>+ xm.getCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://9527haoyunlai.github.io">好运来</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://9527haoyunlai.github.io/2024/07/09/JavaSE/day10-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/">https://9527haoyunlai.github.io/2024/07/09/JavaSE/day10-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/09/JavaSE/day11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">网络编程</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/09/JavaSE/day09-%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81IO%E6%B5%81/" title="字符流，IO流01"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">字符流，IO流01</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/07/09/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/" title="常用方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">常用方法</div></div></a></div><div><a href="/2024/07/09/JavaSE/day01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/" title="面向对象高级01"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">面向对象高级01</div></div></a></div><div><a href="/2024/07/09/JavaSE/day02%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/" title="面向对象高级02"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">面向对象高级02</div></div></a></div><div><a href="/2024/07/09/JavaSE/day03%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/" title="面向对象高级03"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">面向对象高级03</div></div></a></div><div><a href="/2024/07/09/JavaSE/day04-%E5%B8%B8%E7%94%A8API/" title="常用API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">常用API</div></div></a></div><div><a href="/2024/07/09/JavaSE/day07-%E9%9B%86%E5%90%88/" title="集合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="title">集合</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">好运来</div><div class="author-info__description">个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/9527haoyunlai" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chenqi1253@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#day11-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">day11-特殊文件、日志技术、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">一、属性文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 特殊文件概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Properties%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">二、Properties属性文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 属性文件的格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 读取属性文件中的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BE%80%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E4%B8%AD%E5%86%99%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 往属性文件中写键值对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81XML%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">三、XML文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-XML%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 XML文件概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-XML%E8%A7%A3%E6%9E%901"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 XML解析1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-XML%E8%A7%A3%E6%9E%902"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3 XML解析2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-XML%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.4 XML文件写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-XML%E7%BA%A6%E6%9D%9F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">2.5 XML约束（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><span class="toc-number">1.4.</span> <span class="toc-text">四、日志技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 日志概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%93%E7%B3%BB"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 日志的体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Logback%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 Logback快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4 日志配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB-%E7%89%B9%E5%88%AB%E9%87%8D%E8%A6%81"><span class="toc-number">1.4.5.</span> <span class="toc-text">3.5 配置日志级别(特别重要)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">四、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F1"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 线程创建方式1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F2"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 线程的创建方式2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F3"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 线程的创建方式3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 线程的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-number">1.5.5.</span> <span class="toc-text">4.5 线程安全问题(很重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">4.5.1 什么是线程安全问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">4.5.2 用程序模拟线程安全问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.5.6.</span> <span class="toc-text">4.6 线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">4.6.1 同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">4.6.2 同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-3-Lock%E9%94%81"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">4.6.3 Lock锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E4%BA%86%E8%A7%A3"><span class="toc-number">1.5.7.</span> <span class="toc-text">4.7 线程通信(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.5.8.</span> <span class="toc-text">4.8 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">4.8.1 什么是线程池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-number">1.5.8.2.</span> <span class="toc-text">4.8.2 如何创建线程池？(重点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86Runnable%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.5.8.3.</span> <span class="toc-text">4.8.3 使用线程池处理Runnable任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-4-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86Callable%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.5.8.4.</span> <span class="toc-text">4.8.4 使用线程池处理Callable任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-5-%E9%80%9A%E8%BF%87Executors%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.5.8.5.</span> <span class="toc-text">4.8.5 通过Executors来创建线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.5.9.</span> <span class="toc-text">4.9 并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.10.</span> <span class="toc-text">4.10 线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-%E4%B9%90%E8%A7%82%E9%94%81-%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE"><span class="toc-number">1.5.11.</span> <span class="toc-text">4.11 乐观锁(面试常问)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98"><span class="toc-number">1.5.12.</span> <span class="toc-text">4.12 多线程题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/09/SpringBoot+SSM/day01-HTML-CSS/" title="Untitled">Untitled</a><time datetime="2024-07-09T10:46:18.949Z" title="Created 2024-07-09 18:46:18">2024-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/09/SpringBoot+SSM/DataGrip%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/" title="Untitled">Untitled</a><time datetime="2024-07-09T10:46:18.948Z" title="Created 2024-07-09 18:46:18">2024-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/09/SpringBoot+SSM/api%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/" title="Untitled">Untitled</a><time datetime="2024-07-09T10:46:18.947Z" title="Created 2024-07-09 18:46:18">2024-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/09/SpringBoot+SSM/AliOSS/" title="Untitled">Untitled</a><time datetime="2024-07-09T10:46:18.946Z" title="Created 2024-07-09 18:46:18">2024-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/09/SpringBoot+SSM/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/" title="Untitled">Untitled</a><time datetime="2024-07-09T10:46:18.944Z" title="Created 2024-07-09 18:46:18">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 好运来</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>